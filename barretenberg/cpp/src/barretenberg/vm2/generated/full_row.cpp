// AUTOGENERATED FILE
#include "full_row.hpp"
#include "flavor_settings.hpp"

namespace bb::avm2 {
namespace {

template <typename FF> std::string field_to_string(const FF& ff)
{
    std::ostringstream os;
    os << ff;
    std::string raw = os.str();
    auto first_not_zero = raw.find_first_not_of('0', 2);
    std::string result = "0x" + (first_not_zero != std::string::npos ? raw.substr(first_not_zero) : "0");
    return result;
}

} // namespace

template <typename FF> std::vector<std::string> AvmFullRow<FF>::names()
{
    return { "execution_zero",   "execution_input",    "alu_dst_addr", "alu_ia",        "alu_ia_addr",
             "alu_ib",           "alu_ib_addr",        "alu_ic",       "alu_op",        "alu_sel_op_add",
             "execution_clk",    "execution_last",     "execution_pc", "execution_sel", "execution_selector",
             "lookup_dummy_inv", "lookup_dummy_counts" };
}

template <typename FF> RefVector<const FF> AvmFullRow<FF>::as_vector() const
{
    return RefVector<const FF>{
        execution_zero,   execution_input,     alu_dst_addr, alu_ia,        alu_ia_addr,
        alu_ib,           alu_ib_addr,         alu_ic,       alu_op,        alu_sel_op_add,
        execution_clk,    execution_last,      execution_pc, execution_sel, execution_selector,
        lookup_dummy_inv, lookup_dummy_counts,
    };
}

template <typename FF> std::ostream& operator<<(std::ostream& os, AvmFullRow<FF> const& row)
{
    for (const auto& ff : row.as_vector()) {
        os << field_to_string(ff) << ", ";
    }
    return os;
}

// Explicit template instantiation.
template std::ostream& operator<<(std::ostream& os, AvmFullRow<AvmFlavorSettings::FF> const& row);
template std::vector<std::string> AvmFullRow<AvmFlavorSettings::FF>::names();
template RefVector<const AvmFlavorSettings::FF> AvmFullRow<AvmFlavorSettings::FF>::as_vector() const;

} // namespace bb::avm2
