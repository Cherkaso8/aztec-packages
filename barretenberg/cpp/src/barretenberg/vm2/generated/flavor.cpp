// AUTOGENERATED FILE
#include "flavor.hpp"

namespace bb {

Avm2Flavor::AllConstRefValues::AllConstRefValues(
    const RefArray<Avm2Flavor::AllConstRefValues::BaseDataType, Avm2Flavor::NUM_ALL_ENTITIES>& il)
    : execution_zero(il[0])
    , execution_input(il[1])
    , alu_dst_addr(il[2])
    , alu_ia(il[3])
    , alu_ia_addr(il[4])
    , alu_ib(il[5])
    , alu_ib_addr(il[6])
    , alu_ic(il[7])
    , alu_op(il[8])
    , alu_sel_op_add(il[9])
    , execution_clk(il[10])
    , execution_last(il[11])
    , execution_pc(il[12])
    , execution_selector(il[13])
    , lookup_dummy_counts(il[14])
    , lookup_dummy_inv(il[15])
    , execution_pc_shift(il[16])
{}

Avm2Flavor::ProverPolynomials::ProverPolynomials(ProvingKey& proving_key)
{
    for (auto [prover_poly, key_poly] : zip_view(this->get_unshifted(), proving_key.get_all())) {
        ASSERT(flavor_get_label(*this, prover_poly) == flavor_get_label(proving_key, key_poly));
        prover_poly = key_poly.share();
    }
    for (auto [prover_poly, key_poly] : zip_view(this->get_shifted(), proving_key.get_to_be_shifted())) {
        ASSERT(flavor_get_label(*this, prover_poly) == (flavor_get_label(proving_key, key_poly) + "_shift"));
        prover_poly = key_poly.shifted();
    }
}

Avm2Flavor::AllConstRefValues Avm2Flavor::ProverPolynomials::get_row(size_t row_idx) const
{
    return RefArray{ execution_zero[row_idx],
                     execution_input[row_idx],
                     alu_dst_addr[row_idx],
                     alu_ia[row_idx],
                     alu_ia_addr[row_idx],
                     alu_ib[row_idx],
                     alu_ib_addr[row_idx],
                     alu_ic[row_idx],
                     alu_op[row_idx],
                     alu_sel_op_add[row_idx],
                     execution_clk[row_idx],
                     execution_last[row_idx],
                     execution_pc[row_idx],
                     execution_selector[row_idx],
                     lookup_dummy_counts[row_idx],
                     lookup_dummy_inv[row_idx],
                     execution_pc_shift[row_idx] };
}

Avm2Flavor::CommitmentLabels::CommitmentLabels()
{
    Base::execution_zero = "EXECUTION_ZERO";
    Base::execution_input = "EXECUTION_INPUT";
    Base::alu_dst_addr = "ALU_DST_ADDR";
    Base::alu_ia = "ALU_IA";
    Base::alu_ia_addr = "ALU_IA_ADDR";
    Base::alu_ib = "ALU_IB";
    Base::alu_ib_addr = "ALU_IB_ADDR";
    Base::alu_ic = "ALU_IC";
    Base::alu_op = "ALU_OP";
    Base::alu_sel_op_add = "ALU_SEL_OP_ADD";
    Base::execution_clk = "EXECUTION_CLK";
    Base::execution_last = "EXECUTION_LAST";
    Base::execution_pc = "EXECUTION_PC";
    Base::execution_selector = "EXECUTION_SELECTOR";
    Base::lookup_dummy_inv = "LOOKUP_DUMMY_INV";
    Base::lookup_dummy_counts = "LOOKUP_DUMMY_COUNTS";
};

void Avm2Flavor::Transcript::deserialize_full_transcript()
{
    size_t num_frs_read = 0;
    circuit_size = deserialize_from_buffer<uint32_t>(proof_data, num_frs_read);

    for (auto& commitment : commitments) {
        commitment = deserialize_from_buffer<Commitment>(proof_data, num_frs_read);
    }

    for (size_t i = 0; i < CONST_PROOF_SIZE_LOG_N; ++i) {
        sumcheck_univariates.emplace_back(deserialize_from_buffer<bb::Univariate<FF, BATCHED_RELATION_PARTIAL_LENGTH>>(
            Transcript::proof_data, num_frs_read));
    }

    sumcheck_evaluations =
        deserialize_from_buffer<std::array<FF, NUM_ALL_ENTITIES>>(Transcript::proof_data, num_frs_read);

    for (size_t i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; ++i) {
        gemini_fold_comms.push_back(deserialize_from_buffer<Commitment>(proof_data, num_frs_read));
    }

    for (size_t i = 0; i < CONST_PROOF_SIZE_LOG_N; ++i) {
        gemini_fold_evals.push_back(deserialize_from_buffer<FF>(proof_data, num_frs_read));
    }

    shplonk_q_comm = deserialize_from_buffer<Commitment>(proof_data, num_frs_read);

    kzg_w_comm = deserialize_from_buffer<Commitment>(proof_data, num_frs_read);
}

void Avm2Flavor::Transcript::serialize_full_transcript()
{
    size_t old_proof_length = proof_data.size();
    Transcript::proof_data.clear();

    serialize_to_buffer(circuit_size, Transcript::proof_data);

    for (const auto& commitment : commitments) {
        serialize_to_buffer(commitment, Transcript::proof_data);
    }

    for (size_t i = 0; i < CONST_PROOF_SIZE_LOG_N; ++i) {
        serialize_to_buffer(sumcheck_univariates[i], Transcript::proof_data);
    }

    serialize_to_buffer(sumcheck_evaluations, Transcript::proof_data);

    for (size_t i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; ++i) {
        serialize_to_buffer(gemini_fold_comms[i], proof_data);
    }

    for (size_t i = 0; i < CONST_PROOF_SIZE_LOG_N; ++i) {
        serialize_to_buffer(gemini_fold_evals[i], proof_data);
    }

    serialize_to_buffer(shplonk_q_comm, proof_data);
    serialize_to_buffer(kzg_w_comm, proof_data);

    // sanity check to make sure we generate the same length of proof as before.
    ASSERT(proof_data.size() == old_proof_length);
}

Avm2Flavor::PartiallyEvaluatedMultivariates::PartiallyEvaluatedMultivariates(const size_t circuit_size)
{
    // Storage is only needed after the first partial evaluation, hence polynomials of size (n / 2)
    for (auto& poly : get_all()) {
        poly = Polynomial(circuit_size / 2);
    }
}

Avm2Flavor::ProvingKey::ProvingKey(const size_t circuit_size, const size_t num_public_inputs)
    : circuit_size(circuit_size)
    , evaluation_domain(bb::EvaluationDomain<FF>(circuit_size, circuit_size))
    , commitment_key(std::make_shared<CommitmentKey>(circuit_size + 1))
{
    // TODO: These come from PrecomputedEntitiesBase, ideal we'd just call that class's constructor.
    this->log_circuit_size = numeric::get_msb(circuit_size);
    this->num_public_inputs = num_public_inputs;

    // The proving key's polynomials are not allocated here because they are later overwritten
    // AvmComposer::compute_witness(). We should probably refactor this flow.
};

/**
 * @brief Serialize verification key to field elements
 *
 * @return std::vector<FF>
 */
std::vector<Avm2Flavor::VerificationKey::FF> Avm2Flavor::VerificationKey::to_field_elements() const
{
    std::vector<FF> elements = { FF(circuit_size), FF(num_public_inputs) };

    for (auto const& comm : get_all()) {
        std::vector<FF> comm_as_fields = field_conversion::convert_to_bn254_frs(comm);
        elements.insert(elements.end(), comm_as_fields.begin(), comm_as_fields.end());
    }
    return elements;
}

} // namespace bb